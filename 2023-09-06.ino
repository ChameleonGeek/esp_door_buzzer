/* ============================================================================================== */
/*                                       ESP32 DOOR BUZZER                                        */
/*                                       MICHAEL HENDRICKS                                        */
/*                michael@chameleonoriginals.com  https://github.com/ChameleonGeek                */
/*                                                                                                */
/*             THIS IS MEANT TO PROVIDE AN INTERFACE FOR USERS TO CONNECT TO THE ESP              */
/*                VIA WIFI, AUTOMATICALLY BE CONNECTED TO A CAPTIVE PORTAL AND BE                 */
/*             TRANSFERRED TO AN HTTPS CONNECTION SO THE USER CAN AUTHENTICATE WITH               */
/*                               THE ESP AND OPEN A "BUZZ-IN DOOR"                                */
/*                                                                                                */
/*              THIS CODE IS A WORK IN PROGRESS, SO ONLY PROVIDES A PORTION OF THE                */
/*                                  INTENDED FINAL FUNCTIONALITY                                  */
/* ============================================================================================== */
// Sketch uses 1,140,785 bytes (87%) of program storage space (1.2MB APP/1.5MB SPIFFS)
// This will be deployed as Huge App (3MB No OTA/1MB SPIFFS)
// Global variables use 53,712 bytes (16%) of dynamic memory

#define PIN_SWITCH 15  // Pin used to read the switch status
// HIGH => No member present (switch not flipped)
#define PIN_BUZZER  4  // Pin used to actuate the buzzer
#define PIN_LIGHT   2  // Pin used to control "open" light
/* ========================================================================== */
/*                       WIFI SECURITY/CONFIG VARIABLES                       */
/* ========================================================================== */
#define AP_SSID   "DoorNet"      // Replace with your network information
#define AP_PSK    "OpenSesame"   // Replace with your network information

// These variables can be changed to increase/decrease the number of possible
// networks it will try to join.  I develop in one of three places, so chose
// three so I didn't have to change code to work in a different location
#define SSID_NUM 3 // Number of SSIDs the system should try to connect to
String WIFI_SSIDs[SSID_NUM] = {"SSID1", "SSID2", "SSID3"};
String WIFI_PSKs[SSID_NUM] = {"PSK1", "PSK2", "PSK3"};
#define WIFI_ATT_COUNT 30  // Number of loops the system should try to connect
// The first association tends to take a lot longer than subsequent connections.

// Holds the WIFI_SSIDs index of the network the system successfully joined 
// The system will disconnect periodically and scan for possible spoof APs
// This number will make re-join process faster
int foundNet;

// The default android DNS => might be needed for the Captive Portal
IPAddress apIP(8,8,4,4); 

/* ========================================================================== */
/*  CERTIFICATES FOR THE HTTPS SERVER MUST BE INCLUDED IN THE SKETCH FOLDER   */
/*                        AS cert.h AND private_key.h                         */
/*                CERTIFICATES CAN BE GENERATED BY EXECUTING                  */
/*        Arduino/libraries/ESP32_HTTPS_Server/extras/create_cert.sh          */
/* ========================================================================== */
#include "cert.h"
#include "private_key.h"

/* ========================================================================== */
/*                    LIBRARIES REFERENCED BY THIS SKETCH                     */
/*     ESP32_HTTPS_SERVER  https://github.com/fhessel/esp32_https_server      */
/* ========================================================================== */
#include <WiFi.h>            // Needed for WiFi connections (AP and Member) <Arduino core>

#include <HTTPServer.hpp>    // Handles the non-SSL web server  <ESP32_HTTPS_SERVER>
#include <HTTPRequest.hpp>   // Handles requests from users     <ESP32_HTTPS_SERVER>
#include <HTTPResponse.hpp>  // Creates the responses to users  <ESP32_HTTPS_SERVER>

#include <HTTPSServer.hpp>   // Handles the SSL web server      <ESP32_HTTPS_SERVER>
#include <SSLCert.hpp>       // Manages SSL certificate negotiation  <ESP32_HTTPS_SERVER>

#include <DNSServer.h>       // Captive portal requires DNS functionality  <Arduino core>

/* ========================================================================== */
/*                  LIBRARIES AND VARIABLES FOR OLED DISPLAY                  */
/*                           128X64 SSD1306 DISPLAY                           */
/*             WILL BE USED FOR CLEAR COMMUNICATION WITH MEMBERS              */
/*      THE OLED I AM USING USES I2C ADDRESS 0x3C, NOT THE STANDARD 0x3D      */
/* ========================================================================== */
#include <SPI.h>   <Arduino core>
#include <Wire.h>  <Arduino core>
#include <Adafruit_SSD1306.h>  <Adafruit_SSD1306>
#include <Adafruit_GFX.h>      <Can be installed alongside Adafruit_SSD1306>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64

#define OLED_RESET     -1 // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

int OLED_ROWS[7] = {0, 9, 18, 28, 37, 46, 55};  // Make this a variable to play with line spacing
// The OLED doesn't need to be refreshed continuously - it flickers if refreshed too often
#define OLED_PAUSE_COUNT 2048
int OLED_TIMER = 0;  
/* ========================================================================== */
/*                   DEFINE OTHER VARIABLES FOR THE SKETCH                    */
/* ========================================================================== */
// The HTTPS Server comes in a separate namespace. For easier use, include it here.
using namespace httpsserver;

// Create an SSL certificate object from the files included above
SSLCert cert = SSLCert(
  example_crt_DER, example_crt_DER_len,
  example_key_DER, example_key_DER_len
);

// First, we create the HTTPSServer with the certificate created above
HTTPSServer secureServer = HTTPSServer(&cert);

// Additionally, we create an HTTPServer for unencrypted traffic
HTTPServer insecureServer = HTTPServer();

// Declare some handler functions for the various URLs on the server
void handleRoot(HTTPRequest * req, HTTPResponse * res);
void handle404(HTTPRequest * req, HTTPResponse * res);
void handleCaptReq(HTTPRequest * req, HTTPResponse * res);  // May not be required
void handleCapt2(HTTPRequest * req, HTTPResponse * res);    // May not be required

DNSServer dnsServer;  // Variable for the DNS Server object

/* ============================================================================================== */
/*                                      SETUP AND LOOP CODE                                       */
/* ============================================================================================== */
void setup(){
  Serial.begin(115200);

  pinMode(2, OUTPUT);  // Hard code, since it uses the onboard LED pin
  pinMode(PIN_SWITCH, INPUT_PULLUP);  // Switch to be read to determine if a member is present
  pinMode(PIN_BUZZER, OUTPUT); // Pin used to actuate the buzzer
  digitalWrite(PIN_BUZZER, LOW);
  pinMode(PIN_LIGHT, OUTPUT);  // Pin used to turn on Open Light
  digitalWrite(PIN_LIGHT, LOW);
  
  // Initialize the OLED
  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);
  display.clearDisplay();               // Don't show splash screen
  display.setTextSize(1);               // Normal 1:1 pixel scale
  display.setTextColor(SSD1306_WHITE);  // Draw white text
  display.setCursor(0, OLED_ROWS[0]);

  // Track the evolution of the code
  Serial.print("File: ");            Serial.println(__FILE__);
  Serial.print("Compile Date: ");    Serial.println(__DATE__);
  Serial.print("Time: ");            Serial.println(__TIME__);

  Serial.println("Setting up WiFi");
  Serial.println("========================================");
  display.println("Setting up WiFi");
  display.display();
  WiFi.mode(WIFI_AP_STA); // Station _and_ access point mode are both required

  Serial.println("Starting Access Point");
  display.setCursor(0, OLED_ROWS[1]);
  display.println("Starting Access Point");
  display.display();
  WiFi.softAP(AP_SSID, AP_PSK); // Create the Access Point - TODO:: Allow handling of open AP
  // This was copied from a functional Captive Portal sketch.  Not sure if required, but was originally
  // configured to use 8.8.4.4 IP address to mimic Google (Android) primary DNS Server
  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));
  Serial.print("Access Point IP: ");  Serial.println(apIP);
  display.setCursor(0, OLED_ROWS[2]);
  display.print("AP IP: ");
  display.println(apIP);
  display.display();

  WiFiConnect();

  // One functional demo implied DNS needed to start twice - confirm
  Serial.print("Starting DNS Server...");
  display.setCursor(0, OLED_ROWS[0]);
  display.print("DNS (A) ... ");
  display.display();
  if(dnsServer.start(53, "*", apIP)){
    Serial.println("SUCCESS");
    display.println("SUCCESS");
  } else {
    Serial.println("FAILED");
    display.println("FAILED");
  }
  display.display();

  Serial.print("Configuring DNS Server for captive portal function...");
  display.setCursor(0, OLED_ROWS[1]);
  display.print("DNS (B) ... ");
  display.display();
  dnsServer.setTTL(300);
  dnsServer.setErrorReplyCode(DNSReplyCode::NoError);
  if(dnsServer.start(53, "*", apIP)){
    Serial.println("SUCCESS");
    display.println("SUCCESS");
  } else {
    Serial.println("FAILED");
    display.println("FAILED");
  }
  display.display();

  // For every resource available on the server, we need to create a ResourceNode
  // The ResourceNode links URL and HTTP method to a handler function
  ResourceNode * nodeRoot = new ResourceNode("/", "GET", &handleRoot);
  ResourceNode * node404  = new ResourceNode("", "GET", &handle404);
  ResourceNode * nodeCapt = new ResourceNode("/generate_204", "GET", &handleRoot);  // May not be required
  ResourceNode * nodeCapt2 = new ResourceNode("/gen_204", "GET", &handleRoot);      // May not be required

  // Add the root node to the servers. We can use the same ResourceNode on multiple
  // servers (you could also run multiple HTTPS servers)
  secureServer.registerNode(nodeRoot);
  insecureServer.registerNode(nodeRoot);

  // We do the same for the default Node
  secureServer.setDefaultNode(node404);
  insecureServer.setDefaultNode(node404);

  // Add Node for /generate_204 requests (Android Captive Portal Probes)
  // Not sure if these are required
  secureServer.setDefaultNode(nodeCapt);
  insecureServer.setDefaultNode(nodeCapt);

  Serial.print("Starting HTTPS server...");
  display.setCursor(0, OLED_ROWS[2]);
  display.print("HTTPS Server ");
  display.display();
  secureServer.start();
  if (secureServer.isRunning()){
    Serial.println("READY");  
    display.println("READY");
  } else {
    Serial.println("NOT READY");
    display.println("NOT READY");
  }
  display.display();

  Serial.print("Starting HTTP server...");
  display.setCursor(0, OLED_ROWS[3]);
  display.print("HTTP Server  ");
  display.display();
  insecureServer.start();
  if (insecureServer.isRunning()){
    Serial.println("READY");  
    display.println("READY");
  } else {
    Serial.println("NOT READY");
    display.println("NOT READY");
  }
  display.display();

  /* ============================================ */
  /*      ADD SETUP FOR OTHER FUNCTIONALITY       */
  /*      CONFIGURE PIN ATTACHED TO SWITCH,       */
  /*      CONFIGURE LED LIBRARIES, PINS, ETC      */
  /* ============================================ */

  Serial.println("Setup routine complete.");
  display.clearDisplay();
  display.setCursor(0, 16);
  display.setTextSize(2);
  display.println("   SETUP\n COMPLETE");
  display.setTextSize(1);
  display.display();
  //delay(2000);
}

void loop(){
  dnsServer.processNextRequest(); // Manage DNS Requests (Captive Portal)
  insecureServer.loop();          // Have the HTTP server process any requests
  secureServer.loop();            // Have the HTTPS server process any requests


  if ( OLED_TIMER > OLED_PAUSE_COUNT ){
    OLED_TIMER = 1;
    displayStats();
  } else {
    ++OLED_TIMER;    
  }

  /* ============================================ */
  /*             ALL OTHER FUNCTIONS              */
  /*        (CHECK STATUS OF USER SWITCH,         */
  /*  MANAGE LIGHTS TO IMPROVE USER COMMS, ETC.)  */
  /* ============================================ */
  delay(1);
}


/* ============================================================================================== */
/*                                       WEB PAGE HANDLERS                                        */
/* ============================================================================================== */

void handleRoot(HTTPRequest * req, HTTPResponse * res) {
  /* ============================================ */
  /*       HANDLE WEB REQUESTS TO ROOT (/)        */
  /* ============================================ */
  res->setHeader("Content-Type", "text/html");

  res->println("<!DOCTYPE html>");
  res->println("<html>");
  res->println("<head><title>Hello World!</title></head>");
  res->println("<body>");
  res->println("<h1>Hello World!</h1>");

  res->print("<p>Your server is running for ");
  res->print((int)(millis()/1000), DEC);
  res->println(" seconds.</p>");

  // You can check if you are connected over a secure connection, eg. if you
  // want to use authentication and redirect the user to a secure connection
  // for that
  if (req->isSecure()) {
      res->println("<p>You are connected via <strong>HTTPS</strong>.</p>");
  } else {
      res->println("<p>You are connected via <strong>HTTP</strong>.</p>");
  }

  res->println("</body>");
  res->println("</html>");
}

void handle404(HTTPRequest * req, HTTPResponse * res) {
  /* ============================================ */
  /*        HANDLE UNSERVICEABLE REQUESTS         */
  /*             (NO HANDLER DEFINED)             */
  /* ============================================ */
  req->discardRequestBody();
  res->setStatusCode(404);
  res->setStatusText("Not Found");
  res->setHeader("Content-Type", "text/html");
  res->println("<!DOCTYPE html>");
  res->println("<html>");
  res->println("<head><title>Not Found</title></head>");
  res->println("<body><h1>404 Not Found</h1><p>The requested resource was not found on this server.</p></body>");
  res->println("</html>");
}

void handleCaptReq(HTTPRequest * req, HTTPResponse * res) {  // MAY NOT BE REQUIRED
  // This function is meant to handle Android /generate_204 requests.
  // If they return a code 204 and an empty body, the Android will not 
  // initiate a Captive Portal response
  req->discardRequestBody();
  res->setStatusCode(200);
  res->setStatusText("OK");
  res->setHeader("Content-Type", "text/html");
  res->println("<!DOCTYPE html><html><head><title>Hello World!</title></head></html>");
}

void handleCapt2(HTTPRequest * req, HTTPResponse * res) {    // MAY NOT BE REQUIRED
  handleCaptReq(req, res);
}



/* ============================================================================================== */
/*                                 ADDITIONAL FUNCTIONS/CONTROLS                                  */
/* ============================================================================================== */

void WiFiConnect(){
  // Try to connect to WiFi network.  Make it time out and proceed with setup if it can't connect
  Serial.println("Connecting to WiFi");
  display.clearDisplay();
  display.display();
  display.setCursor(0, OLED_ROWS[0]);
  display.println("Connecting to WiFi");
  display.display();
  lightFlash(5);
  Serial.println("Scanning available networks");
  display.setCursor(0, OLED_ROWS[1]);
  display.println("Scanning networks");
  display.display();
  int n = WiFi.scanNetworks();
  Serial.print(n);
  Serial.println(" Networks Found");
  display.setCursor(0, OLED_ROWS[2]);
  display.print(n);
  display.println(" Networks found");
  display.display();
  for (int Index = 0; Index < SSID_NUM; ++Index){
    // Try all networks specified in WIFI_SSIDs
    Serial.print("Looking for SSID ");
    Serial.print(WIFI_SSIDs[Index]);
    for (int indScan = 0; indScan < n; ++indScan){
      // See if WIFI_SSIDs[Index] in found SSIDs
      if (WiFi.SSID(indScan) == WIFI_SSIDs[Index]){
        Serial.println("...FOUND - Connecting");
        display.setCursor(0, OLED_ROWS[3]);
        display.println("Joining Network");
        display.setCursor(0, OLED_ROWS[4]);
        display.println(WIFI_SSIDs[Index]);
        display.display();
        if (NetConnect(Index)){  // Try to connect
          Serial.println("Connection Successful");
          digitalWrite(2, HIGH);
          display.clearDisplay();
          return;
        } else {
          Serial.println("Could not join WiFi network");
          digitalWrite(2, LOW);
          display.clearDisplay();
          return;
        }
      }
    }
    Serial.println("..Not Found");
  }
  display.clearDisplay();
}

bool NetConnect(int NetId){
  // Run connection attempt for the found network
  Serial.print("Connecting to SSID ");
  Serial.println(WIFI_SSIDs[NetId]);
  display.setCursor(0, OLED_ROWS[5]);
  WiFi.begin(WIFI_SSIDs[NetId], WIFI_PSKs[NetId]);
  int tryCount = 0;
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    display.print(".");
    display.display();
    digitalWrite(2, HIGH);
    delay(250);
    digitalWrite(2, LOW);
    delay(250);
    ++tryCount;
    if (tryCount > WIFI_ATT_COUNT){
      Serial.println("\nTIMED OUT");
      display.println("\nTIMED OUT");
      display.display();
      foundNet = 999;
      return false;
    }
  }
  Serial.println("\nSuccess!");
  display.println("\nSuccess!");
  display.display();
  foundNet = NetId;
  display.clearDisplay();
  return true;
}

void lightFlash(int flashCount){
  // Flash the onboard LED to give the user indications of progress/success
  while(flashCount > 0){
    digitalWrite(2, HIGH);
    delay(150);
    digitalWrite(2, LOW);
    delay(150);
    --flashCount;
  }
}

void displayPrep(){
  // Display buffer contents and prepare the display for the next line of text
  display.display();
  display.clearDisplay();
  display.setCursor(0,0);
}

void displayStats(){
  // Displays the current operating mode
  display.clearDisplay();
  display.setCursor(0, OLED_ROWS[0]);
  display.print("AP SSID:"); display.println(AP_SSID);
  display.setCursor(0, OLED_ROWS[1]);
  display.print("PSK:"); display.println(AP_PSK);
  display.setCursor(0, OLED_ROWS[2]);
  display.print("IP Address:"); display.println(apIP);
  display.drawLine(0, OLED_ROWS[3] - 2, 127, OLED_ROWS[3] - 2, SSD1306_WHITE);
  display.setCursor(0, OLED_ROWS[3]);
  display.print("LAN: "); 
  if (WiFi.status() == WL_CONNECTED){
    // Display LAN SSID
    display.println(WIFI_SSIDs[foundNet]);
  } else {
    // Display NOT Connected
    display.fillRect(24, OLED_ROWS[3] - 2, 104, 10, SSD1306_WHITE);
    display.setTextColor(SSD1306_INVERSE);
    display.println("NOT CONNECTED");
    display.setTextColor(SSD1306_WHITE);
  }
  
  display.fillRect(104, 40, 24, 24, SSD1306_WHITE);
  if (!LockStatus()){
    // Draw unlocked symbol
    display.fillRect(108, 44, 16, 16, SSD1306_INVERSE);
    display.setCursor(0, 50);
    display.setTextSize(2);
    display.print("OPEN");    
  } else {    
    display.setCursor(0, 50);
    display.setTextSize(2);
    display.print("CLOSED");    
  }
  display.setTextSize(1);
  display.display();
}

bool LockStatus(){
  // Reads the status of the switch and returns whether the system is "locked"
  if (digitalRead(PIN_SWITCH) == HIGH){
    return true;
  } else {
    return false;
  }
}
